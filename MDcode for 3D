import numpy as np
from numba import njit

@njit
def BD(W_prime, F, tau, T, dt, kBT, D):
    n = int(T / dt)
    x = np.zeros((n, 3))     # 3D positions over time
    time = np.zeros(n)
    SD = np.sqrt(2 * D * dt)
    tau_steps = 2*int(tau / dt)

    # Initialize force components (will be set properly in the loop)
    delta_F_x = 0.0
    delta_F_y = 0.0
    delta_F_z = 0.0

    for i in range(1, n):
        # Gaussian random displacements in 3D
        g_x = np.random.normal(0, SD)
        g_y = np.random.normal(0, SD)
        g_z = np.random.normal(0, SD)

        # Randomize the direction of force every tau
        if (i - 1) % tau_steps == 0:
            # Pick a random direction uniformly on the sphere
            v_x = np.random.normal(0.0, 1.0)
            v_y = np.random.normal(0.0, 1.0)
            v_z = np.random.normal(0.0, 1.0)
            mag_v = np.sqrt(v_x*v_x + v_y*v_y + v_z*v_z)
            v_x /= mag_v
            v_y /= mag_v
            v_z /= mag_v

            # Scale by the desired force magnitude
            delta_F_x = F * v_x
            delta_F_y = F * v_y
            delta_F_z = F * v_z

        # Compute the gradient of W at the current position
        grad_W = W_prime(x[i - 1, 0],
                         x[i - 1, 1],
                         x[i - 1, 2])

        # Update positions
        time[i] = i * dt
        x[i, 0] = x[i - 1, 0] + (D * (-grad_W[0] + delta_F_x) / kBT) * dt + g_x
        x[i, 1] = x[i - 1, 1] + (D * (-grad_W[1] + delta_F_y) / kBT) * dt + g_y
        x[i, 2] = x[i - 1, 2] + (D * (-grad_W[2] + delta_F_z) / kBT) * dt + g_z

    return time, x
